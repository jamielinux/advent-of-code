# Day 9: Part 2

## Instructions

<details>

<summary>Same as Part 1</summary>

You have input like this:

```
3,2
9,2
9,5
6,5
6,8
1,8
1,4
3,4
```

Each line represents the position of a **red tile** in a grid like this (where
`0,0` is the top-left corner):

```
..............
..............
...#.....#....
..............
.#.#..........
......#..#....
..............
..............
.#....#.......
..............
```

You can make a rectangle by choosing two red tiles as opposite corners. For
example, `3,4` and `6,5` can make a rectangle like this:

```
..............
..............
...#.....#....
..............
.#.#OOO.......
...OOO#..#....
..............
..............
.#....#.......
..............
```

</details>

This time, we're told that each tile in the input is a sequence that joins to
form a border:

```
..............
..............
...#OOOOO#....
...O.....O....
.#O#.....O....
.O....#OO#....
.O....O.......
.O....O.......
.#OOOO#.......
..............
```

You can make a rectangle by choosing tiles as opposite corners, but the
rectangle must be contained entirely within the border. In other words,
none of the area of the rectangle can go beyond the edges of the border.

In this example, this would be a rectangle whose corners are the `1,4` tile and
`6,8` tile.

_Q: What is the area of the largest rectangle you can make?_

## Notes

### Overview

The real input has too many unique pairs (100k+), so we need to find a way to
avoid or reduce iterating through all of them.

My key idea was to calculate and store invalid tiles that are immediately
outside the polygon border.

For example, the `+` indicates the invalid tiles:

```
..............
..+++++++++...
..+#OOOOO#+...
+++O.....O+...
+#O#.....O+...
+O....#OO#+...
+O....O++++...
+O....O+......
+#OOOO#+......
++++++++......
```

A particular tile pair can create a valid rectangle if they can reach each
other's row and column without crossing an invalid tile.

We still loop all tile pairs to calculate area, but we can efficiently skip
(with `when:` conditions) any pairs that can't reach each other.

### Details

My approach was to:

- for each tile, store the direction of previous/next tile in the sequence
- calculate `border_tiles` (ie, corner tiles and edge tiles between them)
- calculate `invalid_tiles` based on the direction the border turns
- filter out any `invalid_tiles` that overlap with `border_tiles`
- group invalid tiles into dicts by row and col for efficient lookups
- for each tile, find how far it can "reach" in each direction before
  hitting an invalid tile
- for each unique pair of tiles:
    - skip if they can't reach each other (which bypasses most iterations)
    - calculate the rectangle area
- return the max area

## Playbook runtime

7 minutes 8 seconds.
