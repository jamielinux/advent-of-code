- name: 'reset removable_paper_rolls'
  ansible.builtin.set_fact:
    removable_paper_rolls: []

# If the `pos` being processed is "2,3", the range/product/range creates a 3x3
# area centered on `(2, 3)`:
#
# (1, 2), (1, 3), (1, 4),
# (2, 2), (2, 3), (2, 4),
# (3, 2), (3, 3), (3, 4)
#
# The map/select gives us a list of keys that exist in our sparse grid:
#
# ['1,3', '2,3', '2,4', '3,3']
#
# The second map extracts values from the grid:
#
# [1, 1, 1, 1]
#
# Finally, sum them (subtracting 1 for the paper roll in the center) to get the
# number of adjacent rolls.

- name: 'find paper rolls that can be removed'
  when: adjacent_count < 4
  ansible.builtin.set_fact:
    removable_paper_rolls: '{{ removable_paper_rolls + [pos] }}'
  vars:
    row_idx: "{{ pos.split(',')[0] | int }}"
    cell_idx: "{{ pos.split(',')[1] | int }}"
    adjacent_count: >-
      {{
        range(row_idx | int - 1, row_idx | int + 2) | product(range(cell_idx | int - 1, cell_idx | int + 2))
        | map('join', ',')
        | select('in', grid)
        | map('extract', grid)
        | sum - 1
      }}
  loop: '{{ grid.keys() | list }}'
  loop_control:
    label: '{{ idx }}/{{ (grid | length) - 1 }}'
    loop_var: pos
    index_var: idx

- ansible.builtin.debug:
    msg: >-
      rolls removed so far: {{ start_rolls_count - (grid | length) }}
      ({{ ((now().timestamp() - (start_time | float)) / 60) | round | int }} minutes elapsed)'
  tags: [print_action]

- name: 'update the grid'
  failed_when: (removable_paper_rolls | length) == 0
  ansible.builtin.set_fact:
    grid: >-
      {{
        dict(
          grid.keys()
          | reject('in', dict(removable_paper_rolls | product([1])))
          | product([1])
        )
      }}
