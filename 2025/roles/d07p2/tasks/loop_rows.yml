- name: 'compute splitter info and new beam columns'
  ansible.builtin.set_fact:
    splitter_columns: '{{ dict(splitter_list | product([1])) }}'
    new_beam_columns: '{{ new_cols }}'
    new_beam_count: '{{ beam_count }}'
  vars:
    # Find all '^' cells in this row (positions as integers).
    #
    # --- EXAMPLE ---
    # row                  =>  ['.', '^', '.', '^', '.']
    # zip(range(5))        =>  [('.', 0), ('^', 1), ('.', 2), ('^', 3), ('.', 4)]
    # selectattr(.., '^')  =>  [('^', 1), ('^', 3)]
    # map(attribute='1')   =>  [1, 3]
    splitter_list: >-
      {{
        row
        | zip(range(row | length))
        | selectattr('0', 'eq', '^')
        | map(attribute='1')
        | list
      }}

    # Beams that hit splitters.
    hits: "{{ beam_columns | map('int') | intersect(splitter_list) | list }}"

    # New beam columns from splitting (col-1 and col+1 for each hit).
    #
    # --- EXAMPLE ---
    # hits              =>  [3, 7]
    # product([-1, 1])  =>  [(3, -1), (3, 1), (7, -1), (7, 1)]
    # map('sum')        =>  [2, 4, 6, 8]
    new_cols: "{{ hits | product([-1, 1]) | map('sum') | list }}"

# splitter_columns uses 0/1 as a multiplier mask: adjacent splitters contribute
# their beam counts (multiply by 1), non-splitters nothing (multiply by 0). This
# lets us skip looping through several tasks with separate conditionals (and
# avoid the overhead from Ansible).
- name: 'update beam counts after splitters'
  ansible.builtin.set_fact:
    new_beam_count: >-
      {{
        new_beam_count
        | combine(
          {
            beam: (beam_count[beam] | default(0))
              + (beam_count[beam-1] | default(0)) * (splitter_columns[beam-1] | default(0))
              + (beam_count[beam+1] | default(0)) * (splitter_columns[beam+1] | default(0))
          }
        )
      }}
  loop: '{{ new_beam_columns }}'
  loop_control:
    loop_var: beam

- name: 'zero splitter counts and update beam_columns'
  ansible.builtin.set_fact:
    # Zero out the splitter columns.
    beam_count: >-
      {{ new_beam_count | combine(dict(splitter_columns.keys() | product([0]))) }}

    # Beams that hit splitters are replaced by their splits, while others pass
    # through.
    #
    # --- EXAMPLE ---
    # beam_columns (before)  =>  [3, 5]
    # splitter_columns       =>  {3: 1, 7: 1}
    # new_beam_columns       =>  [2, 4]
    # difference(...)        =>  [5]
    # new + difference       =>  [2, 4, 5]
    # beam_columns (after)   =>  [2, 4, 5]
    beam_columns: >-
      {{
        (
          new_beam_columns
          + (beam_columns | difference(splitter_columns.keys()))
        )
        | sort
        | unique
      }}
