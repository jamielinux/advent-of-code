- name: 'set_fact: input'
  ansible.builtin.set_fact:
    input: |-
      {{
        (
          lookup('ansible.builtin.file', 'input.txt')
        ).splitlines()
      }}

- name: 'facts from the instruction example'
  ansible.builtin.set_fact:
    example_total_boxes: 20
    example_connections: 10

- name: 'facts from the puzzle instructions'
  ansible.builtin.set_fact:
    connections: >-
      {{
        1000
        if (input | length) > example_total_boxes
        else example_connections
      }}
    top_n: 3

- name: 'set_fact: total_boxes'
  ansible.builtin.set_fact:
    total_boxes: '{{ input | length }}'

- name: 'set some facts useful for labels'
  ansible.builtin.set_fact:
    total_boxes0: '{{ total_boxes - 1 }}'

- name: 'find the largest coordinate value (x, y or z)'
  ansible.builtin.set_fact:
    max_coordinate_value: >-
      {{
        (
          input | join(',') | split(',') | map('int') | max
        ) + 1
      }}


# --------------------------------------------------------#
- ansible.builtin.debug:
    msg: 'preparing dict of junction boxes'
  tags: [print_action]
# --------------------------------------------------------#

- name: 'set_fact: boxes'
  ansible.builtin.set_fact:
    boxes: >-
      {{
        boxes | default({}) | combine({box: ''})
      }}
  loop: '{{ input }}'
  loop_control:
    label: 'box: {{ idx }}/{{ total_boxes0 }}'
    loop_var: box
    index_var: idx

# --- EXAMPLE ---
# "boxes": {
#     "145,903,56": "",
#     "175,842,730": "",
#     "224,582,78": "",
#     "284,531,647": "",
#     "316,941,82": "",
#     ...
# }


# --------------------------------------------------------#
- ansible.builtin.debug:
    msg: 'finding pairs'
  tags: [print_action]
# --------------------------------------------------------#

# To avoid iterating every unique pair of junction boxes, we can split the 3D
# area into a grid of cells (eg, 12x12x12) and only pair a junction box with
# others in the same cell or the 26 adjacent cells.
#
# The offset [dx, dy, dz] is an adjacent cell's position relative to the current
# cell. To avoid double-counting pairs, we always use a forward offset. An
# offset is "forward" if it's lexicographically greater than [0, 0, 0].
- name: 'define forward neighbour offsets'
  ansible.builtin.set_fact:
    forward_offsets:
      - [0, 0, 1]
      - [0, 1, -1]
      - [0, 1, 0]
      - [0, 1, 1]
      - [1, -1, -1]
      - [1, -1, 0]
      - [1, -1, 1]
      - [1, 0, -1]
      - [1, 0, 0]
      - [1, 0, 1]
      - [1, 1, -1]
      - [1, 1, 0]
      - [1, 1, 1]

# Assuming n junction boxes that are uniformly distributed, the ideal grid has
# n^(1/3) divisions per axis (ie, one box per cell). For example, 10x10x10 grid
# for 1000 uniformly distributed junction boxes. To account for variance in
# distribution, we use a multiplier of 1.2.
- name: 'guesstimate optimal grid divisions'
  ansible.builtin.set_fact:
    optimal_grid_divisions: >-
      {{ [3, (1.2 * (total_boxes ** (1.0/3))) | round | int] | max }}

- name: 'set_fact: grid_sufficient'
  ansible.builtin.set_fact:
    grid_sufficient: false

- name: 'try optimal grid'
  when: optimal_grid_divisions > 2
  vars:
    grid_divisions: '{{ optimal_grid_divisions }}'
  ansible.builtin.include_tasks:
    file: grid_find_pairs.yml

- name: 'fallback to 2x2x2 grid if not sufficient'
  when: not grid_sufficient | bool
  vars:
    grid_divisions: 2
  ansible.builtin.include_tasks:
    file: grid_find_pairs.yml

# --- EXAMPLE ---
# "sorted_pairs": [
#     {
#         "distance_squared": 23466,
#         "point_a": "731,92,483",
#         "point_b": "838,156,394"
#     },
#     {
#         "distance_squared": 24994,
#         "point_a": "493,287,851",
#         "point_b": "593,224,956"
#     },
#     ...
# ]


# --------------------------------------------------------#
- ansible.builtin.debug:
    msg: 'connecting junction boxes'
  tags: [print_action]
# --------------------------------------------------------#

- name: 'set_fact: n_closest_pairs'
  ansible.builtin.set_fact:
    n_closest_pairs: '{{ sorted_pairs[:connections] }}'

- name: 'connect boxes'
  when: box_a_circuit != box_b_circuit or box_a_circuit == ''
  vars:
    box_a_circuit: '{{ boxes[conn.point_a] }}'
    box_b_circuit: '{{ boxes[conn.point_b] }}'
  ansible.builtin.set_fact:
    boxes: >-
      {{
        boxes | combine(
          {conn.point_a: conn.point_a, conn.point_b: conn.point_a}
          if (box_a_circuit == '' and box_b_circuit == '')
          else (
            {conn.point_b: box_a_circuit}
            if (box_a_circuit != '' and box_b_circuit == '')
            else (
              {conn.point_a: box_b_circuit}
              if (box_a_circuit == '' and box_b_circuit != '')
              else (
                boxes
                | dict2items
                | selectattr('value', 'eq', box_b_circuit)
                | map('combine', {'value': box_a_circuit})
                | items2dict
              )
            )
          )
        )
      }}
  loop: '{{ n_closest_pairs }}'
  loop_control:
    label: 'conn: {{ idx }}/{{ connections }}'
    loop_var: conn
    index_var: idx

# --- EXAMPLE ---
# "boxes": {
#     "145,903,56": "145,903,56",
#     "175,842,730": "78,829,914",
#     "224,582,78": "",
#     "284,531,647": "",
#     "316,941,82": "145,903,56",
#     ...
# }


# --------------------------------------------------------#
- ansible.builtin.debug:
    msg: 'finding solution'
  tags: [print_action]
# --------------------------------------------------------#

- name: 'count circuit lengths'
  ansible.builtin.set_fact:
    circuit_lengths: >-
      {{
        boxes
        | dict2items
        | selectattr('value', 'ne', '')
        | map(attribute='value')
        | community.general.counter
        | dict2items
        | sort(attribute='value', reverse=true)
      }}

# --- EXAMPLE ---
# "circuit_lengths": [
#     {
#         "key": "493,287,851",
#         "value": 5
#     },
#     {
#         "key": "731,92,483",
#         "value": 3
#     },
#     ...
# ]

- name: 'set_fact: solution'
  ansible.builtin.set_fact:
    solution: '{{ solution | default(1) * item }}'
  loop: "{{ circuit_lengths[:top_n] | map(attribute='value') }}"

- name: 'print solution'
  tags: [print_action]
  ansible.builtin.debug:
    msg: 'ðŸŽ„ SOLUTION ðŸŽ„: {{ solution }}'
