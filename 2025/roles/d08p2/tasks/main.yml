- name: 'set_fact: input'
  ansible.builtin.set_fact:
    input: |-
      {{
        (
          lookup('ansible.builtin.file', 'input.txt')
        ).splitlines()
      }}

- name: 'set_fact: total_boxes'
  ansible.builtin.set_fact:
    total_boxes: '{{ input | length }}'

- name: 'set some facts useful for labels'
  ansible.builtin.set_fact:
    total_boxes0: '{{ total_boxes - 1 }}'

- name: 'find the largest coordinate value (x, y or z)'
  ansible.builtin.set_fact:
    max_coordinate_value: >-
      {{
        (
          input | join(',') | split(',') | map('int') | max
        ) + 1
      }}


# --------------------------------------------------------#
- ansible.builtin.debug:
    msg: 'preparing dict of junction boxes'
  tags: [print_action]
# --------------------------------------------------------#

- name: 'set_fact: boxes'
  ansible.builtin.set_fact:
    boxes: >-
      {{
        boxes | default({}) | combine({box: ''})
      }}
  loop: '{{ input }}'
  loop_control:
    label: 'box: {{ idx }}/{{ total_boxes0 }}'
    loop_var: box
    index_var: idx

# --- EXAMPLE ---
# "boxes": {
#     "145,903,56": "",
#     "175,842,730": "",
#     "224,582,78": "",
#     "284,531,647": "",
#     "316,941,82": "",
#     ...
# }


# --------------------------------------------------------#
- ansible.builtin.debug:
    msg: 'finding pairs'
  tags: [print_action]
# --------------------------------------------------------#

# To avoid iterating every unique pair of junction boxes, we can split the 3D
# area into a grid of cells (eg, 12x12x12) and only pair a junction box with
# others in the same cell or the 26 adjacent cells.
#
# The offset [dx, dy, dz] is an adjacent cell's position relative to the current
# cell. To avoid double-counting pairs, we always use a forward offset. An
# offset is "forward" if it's lexicographically greater than [0, 0, 0].

- name: 'define forward neighbour offsets'
  ansible.builtin.set_fact:
    forward_offsets:
      - [0, 0, 1]
      - [0, 1, -1]
      - [0, 1, 0]
      - [0, 1, 1]
      - [1, -1, -1]
      - [1, -1, 0]
      - [1, -1, 1]
      - [1, 0, -1]
      - [1, 0, 0]
      - [1, 0, 1]
      - [1, 1, -1]
      - [1, 1, 0]
      - [1, 1, 1]

# In Part 1 we knew we'd need the 1000 closest pairs, regardless of how many
# connections are made. In Part 2 we need N-1 connections but can't predict how
# many pairs that requires (as some pairs are noops when both boxes are already
# in the same circuit).
#
# We'll start with the same formula as Part 1, and if we don't have enough
# connections after that then keep making the grid less granular until we do.

- name: 'guesstimate optimal grid divisions'
  ansible.builtin.set_fact:
    optimal_grid_divisions: >-
      {{ [3, (1.2 * (total_boxes ** (1.0/3))) | round | int] | max }}

- name: 'initialize connection tracking'
  ansible.builtin.set_fact:
    is_fully_connected: false
    connections_made: 0
    last_two_boxes: []

# The last 2x2x2 grid is the same as brute force (because all cells are
# adjacent), so we're guaranteed to get a solution in the end. In reality,
# both the example input and real input should get a solution before this.
- name: 'try grids'
  vars:
    grid_sizes_to_try: >-
      {{
        [optimal_grid_divisions, 12, 9, 6, 3, 2]
        | select('le', optimal_grid_divisions)
        | unique
        | sort(reverse=true)
      }}
  ansible.builtin.include_tasks:
    file: try_grids.yml


# --------------------------------------------------------#
- ansible.builtin.debug:
    msg: 'calculating solution'
  tags: [print_action]
# --------------------------------------------------------#

- name: 'set_fact: solution'
  ansible.builtin.set_fact:
    solution: >-
      {{
        ((last_two_boxes[0] | split(','))[0] | int) *
        ((last_two_boxes[1] | split(','))[0] | int)
      }}

- name: 'print solution'
  tags: [print_action]
  ansible.builtin.debug:
    msg: 'ðŸŽ„ SOLUTION ðŸŽ„: {{ solution }}'
